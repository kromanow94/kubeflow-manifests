# NOTE: the manifests were taken from kubeflow/manifests with tag v1.8.0-rc.1 (or v1.8.0-rc.0)

# NOTE: try disabling cache in the ml-pipeline
# or, try using newer version

# This namespace allows you to define where the services will be installed into
# if not set then they will use the namespace of the release
# This is helpful when installing Kubeflow as a chart dependency (sub chart).
namespace: ""

# Katib chart config
katib:
  enabled: true
  defaults:
    image:
      registry: docker.io
      #    tag: "latest"
      tag: v0.16.0
      pullPolicy: IfNotPresent
    autoscaling:
      # If autoscaling is disabled, replica count for a component is equal to minReplicas.
      enabled: false
      minReplicas: 1
      maxReplicas: 3
      targetCPUUtilizationPercentage: 80
      targetMemoryUtilizationPercentage: 80
    podDisruptionBudget: { }
    nodeSelector: { }
    tolerations: [ ]
    affinity: { }
    topologySpreadConstraints:
    terminationGracePeriodSeconds:
    containerSecurityContext:
  controller:
    enabled: true
    name: katib-controller
    image:
      repository: kubeflowkatib/katib-controller
      registryOverwrite:
      tagOverwrite:
      pullPolicyOverwrite:
    autoscaling:
      # If autoscaling is disabled, replica count for a component is equal to minReplicas.
      enabled:
      minReplicas:
      maxReplicas:
      targetCPUUtilizationPercentage:
      targetMemoryUtilizationPercentage:
    service:
      create: true
      annotations:
        prometheus.io/port: "8080"
        prometheus.io/scheme: http
        prometheus.io/scrape: "true"
    serviceAccount:
      create: true
      name:
      annotations:
  dbmanager:
    enabled: true
    name: katib-db-manager
    image:
      repository: kubeflowkatib/katib-db-manager
      registryOverwrite:
      tagOverwrite:
      pullPolicyOverwrite:
    autoscaling:
      # If autoscaling is disabled, replica count for a component is equal to minReplicas.
      enabled:
      minReplicas:
      maxReplicas:
      targetCPUUtilizationPercentage:
      targetMemoryUtilizationPercentage:
    annotations:
      sidecar.istio.io/inject: "false"
    service:
      create: true
      annotations:
      type: ClusterIP
    config:
      db:
        secret:
          create: true # Set to false to manually create proper secret if no programatic secret provider is available AVP etc https://argocd-vault-plugin.readthedocs.io/en/stable/config/
          name: katib-db-secrets
          data: # Should be migrated to AVP or similar so not in plaintext
            POSTGRES_USER: a2F0aWI=  # katib
            POSTGRES_PASSWORD: a2F0aWI=  # katib
            POSTGRES_DB: a2F0aWI=  # katib
        existingSecretName: # katib-db-secrets
        driver:
          value: postgres
          secretKeyRef:
            name:
            key: driver
        host:
          value: postgres
          secretKeyRef:
            name:
            key: host
        port:
          value: 3306
          secretKeyRef:
            name:
            key: port
        databaseName:
          value: katib # Was postgres, shouldn't this go into a "katib" db?
          secretKeyRef:
            name:
            key: databaseName
        user:
          value: a2F0aWI=  # katib
          secretKeyRef:
            name:
            key: username
        password:
          value: a2F0aWI=  # katib
          secretKeyRef:
            name:
            key: password
  ui:
    enabled: true
    name: katib-ui
    urlPrefix: /katib
    image:
      repository: kubeflowkatib/katib-ui
      registryOverwrite:
      tagOverwrite:
      pullPolicyOverwrite:
    serviceAccount:
      create: true
      name:
      annotations:
    service:
      create: true
      annotations:
  istioIntegration:
    create: true
    enabled: true
    authorizationMode: ingressgateway
    gateway:
      name: kubeflow-gateway
  config:
    init:
      certGenerator:
        enable: false
      controller:
        webhookPort: 8443
        trialResources:
          - Job.v1.batch
    #        - TFJob.v1.kubeflow.org
    #        - PyTorchJob.v1.kubeflow.org
    #        - MPIJob.v1.kubeflow.org
    #        - XGBoostJob.v1.kubeflow.org
    #        - MXJob.v1.kubeflow.org
    runtime:
      metricsCollectors:
        - kind: StdOut
          image: docker.io/kubeflowkatib/file-metrics-collector:v0.17.0-rc.0
        - kind: File
          image: docker.io/kubeflowkatib/file-metrics-collector:v0.17.0-rc.0
        - kind: TensorFlowEvent
          image: docker.io/kubeflowkatib/tfevent-metrics-collector:v0.17.0-rc.0
          resources:
            limits:
              memory: 1Gi
      suggestions:
        - algorithmName: random
          image: docker.io/kubeflowkatib/suggestion-hyperopt:v0.17.0-rc.0
        - algorithmName: tpe
          image: docker.io/kubeflowkatib/suggestion-hyperopt:v0.17.0-rc.0
        - algorithmName: grid
          image: docker.io/kubeflowkatib/suggestion-optuna:v0.17.0-rc.0
        - algorithmName: hyperband
          image: docker.io/kubeflowkatib/suggestion-hyperband:v0.17.0-rc.0
        - algorithmName: bayesianoptimization
          image: docker.io/kubeflowkatib/suggestion-skopt:v0.17.0-rc.0
        - algorithmName: cmaes
          image: docker.io/kubeflowkatib/suggestion-goptuna:v0.17.0-rc.0
        - algorithmName: sobol
          image: docker.io/kubeflowkatib/suggestion-goptuna:v0.17.0-rc.0
        - algorithmName: multivariate-tpe
          image: docker.io/kubeflowkatib/suggestion-optuna:v0.17.0-rc.0
        - algorithmName: enas
          image: docker.io/kubeflowkatib/suggestion-enas:v0.17.0-rc.0
          resources:
            limits:
              memory: 400Mi
        - algorithmName: darts
          image: docker.io/kubeflowkatib/suggestion-darts:v0.17.0-rc.0
        - algorithmName: pbt
          image: docker.io/kubeflowkatib/suggestion-pbt:v0.17.0-rc.0
          persistentVolumeClaimSpec:
            accessModes:
              - ReadWriteMany
            resources:
              requests:
                storage: 5Gi
      earlyStoppings:
        - algorithmName: medianstop
          image: docker.io/kubeflowkatib/earlystopping-medianstop:v0.17.0-rc.0
# one of ['cluster', 'namespace']
# 'namespace' is not yet fully supported.
# Maybe rename to 'deploymentScope'?
deploymentMode: cluster

imagePullSecrets: []
nameOverride: ""
fullnameOverride: ""

defaults:
  image:
    registry: docker.io
    # tag: "latest"
    tag: v1.8.0
    pullPolicy: IfNotPresent
  autoscaling:
    # If autoscaling is disabled, replica count for a component is equal to minReplicas.
    enabled: false
    minReplicas: 1
    maxReplicas: 3
    targetCPUUtilizationPercentage: 80
    targetMemoryUtilizationPercentage: 80
  podDisruptionBudget: {}
  nodeSelector: {}
  tolerations: []
  affinity: {}
  topologySpreadConstraints:
  terminationGracePeriodSeconds:
  containerSecurityContext:

admissionWebhook:
  enabled: true
  image:
    repository: kubeflownotebookswg/poddefaults-webhook
    registryOverwrite:
    tagOverwrite:
    pullPolicyOverwrite:
  resources:
    {}
    # limits:
    #   cpu: 100m
    #   memory: 128Mi
    # requests:
    #   cpu: 100m
    #   memory: 128Mi
  service:
    create: true
    annotations:
    type: ClusterIP
  autoscaling:
    # If autoscaling is disabled, replica count for a component is equal to minReplicas.
    enabled:
    minReplicas:
    maxReplicas:
    targetCPUUtilizationPercentage:
    targetMemoryUtilizationPercentage:
  podDisruptionBudget: {}
  rbac:
    create: true
  serviceAccount:
    create: true
    name:
    annotations:
  nodeSelector:
  tolerations:
  affinity:
  topologySpreadConstraints:
  containerSecurityContext:

centraldashboard:
  enabled: true
  image:
    repository: kubeflownotebookswg/centraldashboard
    registryOverwrite:
    tagOverwrite:
    pullPolicyOverwrite:
  resources:
    {}
    # limits:
    #   cpu: 100m
    #   memory: 128Mi
    # requests:
    #   cpu: 100m
    #   memory: 128Mi
  service:
    create: true
    annotations:
    type: ClusterIP
  autoscaling:
    # If autoscaling is disabled, replica count for a component is equal to minReplicas.
    enabled:
    minReplicas:
    maxReplicas:
    targetCPUUtilizationPercentage:
    targetMemoryUtilizationPercentage:
  podDisruptionBudget: {}
  rbac:
    create: true
  serviceAccount:
    create: true
    name:
    annotations:
  nodeSelector:
  tolerations:
  affinity:
  topologySpreadConstraints:
  containerSecurityContext:
  config:
    # This enables the automatic profile creation.
    enableRegistrationFlow: false
    logoutURL: "/authservice/logout"
    forceIFrame: true
    links:
      externalLinks:
      menuLinks:
        - type: item
          link: /jupyter/
          text: Notebooks
          icon: book
        - type: item
          link: /tensorboards/
          text: Tensorboards
          icon: assessment
        - type: item
          link: /volumes/
          text: Volumes
          icon: device:storage
        - type: item
          link: /models/
          text: Endpoints
          icon: kubeflow:models
        - type: item
          link: /katib/
          text: Experiments (Katib)
          icon: kubeflow:katib
        - type: item
          text: Experiments (KFP)
          link: /pipeline/#/experiments
          icon: done-all
        - type: item
          link: /pipeline/#/pipelines
          text: Pipelines
          icon: kubeflow:pipeline-centered
        - type: item
          link: /pipeline/#/runs
          text: Runs
          icon: maps:directions-run
        - type: item
          link: /pipeline/#/recurringruns
          text: Recurring Runs
          icon: device:access-alarm
        - type: item
          link: /pipeline/#/artifacts
          text: Artifacts
          icon: editor:bubble-chart
        - type: item
          link: /pipeline/#/executions
          text: Executions
          icon: av:play-arrow
      quickLinks:
        - text: Upload a pipeline
          desc: Pipelines
          link: /pipeline/
        - text: View all pipeline runs
          desc: Pipelines
          link: /pipeline/#/runs
        - text: Create a new Notebook server
          desc: Notebook Servers
          # NOTE(kromanow94): it's probably not needed to add namespace here...
          # at least in multi user mode.
          # TODO(kromanow94): check if this is needed...
          # link: /jupyter/new?namespace=kubeflow
          link: /jupyter/new
        - text: View Katib Experiments
          desc: Katib
          link: /katib/
      documentationItems:
        - text: Getting Started with Kubeflow
          desc: Get your machine-learning workflow up and running on Kubeflow
          link: https://www.kubeflow.org/docs/started/getting-started/
        - text: MiniKF
          desc: A fast and easy way to deploy Kubeflow locally
          link: https://www.kubeflow.org/docs/distributions/minikf/
        - text: Microk8s for Kubeflow
          desc: Quickly get Kubeflow running locally on native hypervisors
          link: https://www.kubeflow.org/docs/distributions/microk8s/kubeflow-on-microk8s/
        - text: Kubeflow on GCP
          desc: Running Kubeflow on Kubernetes Engine and Google Cloud Platform
          link: https://www.kubeflow.org/docs/gke/
        - text: Kubeflow on AWS
          desc: Running Kubeflow on Elastic Container Service and Amazon Web Services
          link: https://www.kubeflow.org/docs/aws/
        - text: Requirements for Kubeflow
          desc: Get more detailed information about using Kubeflow and its components
          link: https://www.kubeflow.org/docs/started/requirements/

notebooks:
  enabled: true
  jupyterWebApp:
    enabled: true
    image:
      repository: kubeflownotebookswg/jupyter-web-app
      registryOverwrite:
      tagOverwrite:
      pullPolicyOverwrite:
    resources:
      {}
      # limits:
      #   cpu: 100m
      #   memory: 128Mi
      # requests:
      #   cpu: 100m
      #   memory: 128Mi
    service:
      create: true
      annotations:
      type: ClusterIP
    autoscaling:
      # If autoscaling is disabled, replica count for a component is equal to minReplicas.
      enabled:
      minReplicas:
      maxReplicas:
      targetCPUUtilizationPercentage:
      targetMemoryUtilizationPercentage:
    podDisruptionBudget: {}
    rbac:
      create: true
    serviceAccount:
      create: true
      name:
      annotations:
    nodeSelector:
    tolerations:
    affinity:
    topologySpreadConstraints:
    containerSecurityContext:
    # TODO: embed into config
    urlPrefix: /jupyter
    uiFlavor: default
    secureCookies: true
    logos:
      # if this is defined, the configmap with logos will not be created but
      # the one provided with customConfigMap will be used.
      customConfigMap:
      # if below values are defined, those will be used for the icons
      # instead of defaults
      icons:
        jupyterIconSvg:
        jupyterLabLogoSvg:
        groupOneIconSvg:
        groupOneLogoSvg:
        groupTwoIconSvg:
        groupTwoLogoSvg:
    spawnerFormDefaults:
      # --------------------------------------------------------------
      # Configuration file for the Kubeflow Notebooks UI.
      #
      # About the `readOnly` configs:
      #  - when `readOnly` is set to "true", the respective option
      #    will be disabled for users and only set by the admin
      #  - when 'readOnly' is missing, it defaults to 'false'
      # --------------------------------------------------------------

      ################################################################
      # Container Images
      ################################################################
      # if users can input custom images, or only select from dropdowns
      allowCustomImage: true

      # if the registry of the container image is hidden from display
      hideRegistry: true

      # if the tag of the container image is hidden from display
      hideTag: false

      # configs for the ImagePullPolicy
      imagePullPolicy:
        readOnly: false

        # the default ImagePullPolicy
        # (possible values: "Always", "IfNotPresent", "Never")
        value: IfNotPresent

      ################################################################
      # Jupyter-like Container Images
      #
      # NOTES:
      #  - the `image` section is used for "Jupyter-like" apps whose
      #    HTTP path is configured by the "NB_PREFIX" environment variable
      ################################################################
      image:
        # the default container image
        value: kubeflownotebookswg/jupyter-scipy:v1.8.0-rc.0

        # the list of available container images in the dropdown
        options:
          - kubeflownotebookswg/jupyter-scipy:v1.8.0-rc.0
          - kubeflownotebookswg/jupyter-pytorch-full:v1.8.0-rc.0
          - kubeflownotebookswg/jupyter-pytorch-cuda-full:v1.8.0-rc.0
          - kubeflownotebookswg/jupyter-tensorflow-full:v1.8.0-rc.0
          - kubeflownotebookswg/jupyter-tensorflow-cuda-full:v1.8.0-rc.0

      ################################################################
      # VSCode-like Container Images (Group 1)
      #
      # NOTES:
      #  - the `imageGroupOne` section is used for "VSCode-like" apps that
      #    expose themselves under the HTTP root path "/" and support path
      #    rewriting without breaking
      #  - the annotation `notebooks.kubeflow.org/http-rewrite-uri: "/"` is
      #    set on Notebooks spawned by this group, to make Istio rewrite
      #    the path of HTTP requests to the HTTP root
      ################################################################
      imageGroupOne:
        # the default container image
        value: kubeflownotebookswg/codeserver-python:v1.8.0-rc.0

        # the list of available container images in the dropdown
        options:
          - kubeflownotebookswg/codeserver-python:v1.8.0-rc.0

      ################################################################
      # RStudio-like Container Images (Group 2)
      #
      # NOTES:
      #  - the `imageGroupTwo` section is used for "RStudio-like" apps whose
      #    HTTP path is configured by the "X-RStudio-Root-Path" header
      #  - the annotation `notebooks.kubeflow.org/http-rewrite-uri: "/"` is
      #    set on Notebooks spawned by this group, to make Istio rewrite
      #    the path of HTTP requests to the HTTP root
      #  - the annotation `notebooks.kubeflow.org/http-headers-request-set` is
      #    set on Notebooks spawned by this group, such that Istio injects the
      #    "X-RStudio-Root-Path" header to all request
      ################################################################
      imageGroupTwo:
        # the default container image
        value: kubeflownotebookswg/rstudio-tidyverse:v1.8.0-rc.0

        # the list of available container images in the dropdown
        options:
          - kubeflownotebookswg/rstudio-tidyverse:v1.8.0-rc.0

      ################################################################
      # CPU Resources
      ################################################################
      cpu:
        readOnly: false

        # the default cpu request for the container
        value: "0.5"

        # a factor by which to multiply the CPU request calculate the cpu limit
        # (to disable cpu limits, set as "none")
        limitFactor: "1.2"

      ################################################################
      # Memory Resources
      ################################################################
      memory:
        readOnly: false

        # the default memory request for the container
        value: "1.0Gi"

        # a factor by which to multiply the memory request calculate the memory limit
        # (to disable memory limits, set as "none")
        limitFactor: "1.2"

      ################################################################
      # GPU/Device-Plugin Resources
      ################################################################
      gpus:
        readOnly: false

        # configs for gpu/device-plugin limits of the container
        # https://kubernetes.io/docs/tasks/manage-gpus/scheduling-gpus/#using-device-plugins
        value:
          # the `limitKey` of the default vendor
          # (to have no default, set as "")
          vendor: ""

          # the list of available vendors in the dropdown
          #  `limitsKey` - what will be set as the actual limit
          #  `uiName` - what will be displayed in the dropdown UI
          vendors: []
          #vendors:
          #  - limitsKey: "nvidia.com/gpu"
          #    uiName: "NVIDIA"
          #  - limitsKey: "amd.com/gpu"
          #    uiName: "AMD"

          # the default value of the limit
          # (possible values: "none", "1", "2", "4", "8")
          num: "none"

      ################################################################
      # Workspace Volumes
      ################################################################
      workspaceVolume:
        readOnly: false

        # the default workspace volume to be created and mounted
        # (to have no default, set `value: null`)
        value:
          mount: /home/jovyan

          # pvc configs for creating new workspace volumes
          # https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.24/#persistentvolumeclaim-v1-core
          newPvc:
            metadata:
              # "{notebook-name}" is replaced with the Notebook name
              name: "{notebook-name}-workspace"
            spec:
              #storageClassName: my-storage-class
              resources:
                requests:
                  storage: 5Gi
              accessModes:
                - ReadWriteOnce

      ################################################################
      # Data Volumes
      ################################################################
      dataVolumes:
        readOnly: false

        # a list of additional data volumes to be created and/or mounted
        value: []
        #value:
        #  - mount: /home/jovyan/datavol-1
        #    newPvc:
        #      metadata:
        #        name: "{notebook-name}-datavol-1"
        #      spec:
        #        resources:
        #          requests:
        #            storage: 5Gi
        #        accessModes:
        #          - ReadWriteOnce
        #
        #  - mount: /home/jovyan/datavol-1
        #    existingSource:
        #      persistentVolumeClaim:
        #        claimName: "test-pvc"

      ################################################################
      # Affinity
      ################################################################
      affinityConfig:
        readOnly: false

        # the `configKey` of the default affinity config
        # (to have no default, set as "")
        # (if `readOnly`, the default `value` will be the only accessible option)
        value: ""

        # the list of available affinity configs in the dropdown
        options: []
        #options:
        #  - configKey: "dedicated_node_per_notebook"
        #    displayName: "Dedicated Node Per Notebook"
        #    affinity:
        #      # Require a Node with label `lifecycle=kubeflow-notebook`
        #      nodeAffinity:
        #        requiredDuringSchedulingIgnoredDuringExecution:
        #          nodeSelectorTerms:
        #            - matchExpressions:
        #                - key: "lifecycle"
        #                  operator: "In"
        #                  values:
        #                    - "kubeflow-notebook"
        #
        #      # Require a Node WITHOUT an existing Pod having `notebook-name` label
        #      podAntiAffinity:
        #        requiredDuringSchedulingIgnoredDuringExecution:
        #          - labelSelector:
        #              matchExpressions:
        #                - key: "notebook-name"
        #                  operator: "Exists"
        #            topologyKey: "kubernetes.io/hostname"
        #            # WARNING: `namespaceSelector` is Beta in 1.22 and Stable in 1.24,
        #            #          setting to {} is required for affinity to work across Namespaces
        #            namespaceSelector: {}

      ################################################################
      # Tolerations
      ################################################################
      tolerationGroup:
        readOnly: false

        # the `groupKey` of the default toleration group
        # (to have no default, set as "")
        # (if `readOnly`, the default `value` will be the only accessible option)
        value: ""

        # the list of available toleration groups in the dropdown
        options: []
        #options:
        #  - groupKey: "group_1"
        #    displayName: "4 CPU 8Gb Mem at ~$X.XXX USD per day"
        #    tolerations:
        #      - key: "dedicated"
        #        operator: "Equal"
        #        value: "kubeflow-c5.xlarge"
        #        effect: "NoSchedule"
        #
        #  - groupKey: "group_2"
        #    displayName: "8 CPU 16Gb Mem at ~$X.XXX USD per day"
        #    tolerations:
        #      - key: "dedicated"
        #        operator: "Equal"
        #        value: "kubeflow-c5.2xlarge"
        #        effect: "NoSchedule"
        #
        #  - groupKey: "group_3"
        #    displayName: "16 CPU 32Gb Mem at ~$X.XXX USD per day"
        #    tolerations:
        #      - key: "dedicated"
        #        operator: "Equal"
        #        value: "kubeflow-c5.4xlarge"
        #        effect: "NoSchedule"
        #
        #  - groupKey: "group_4"
        #    displayName: "32 CPU 256Gb Mem at ~$X.XXX USD per day"
        #    tolerations:
        #      - key: "dedicated"
        #        operator: "Equal"
        #        value: "kubeflow-r5.8xlarge"
        #        effect: "NoSchedule"

      ################################################################
      # Shared Memory
      ################################################################
      shm:
        readOnly: false

        # the default state of the "Enable Shared Memory" toggle
        value: true

      ################################################################
      # PodDefaults
      ################################################################
      configurations:
        readOnly: false

        # the list of PodDefault names that are selected by default
        # (take care to ensure these PodDefaults exist in Profile Namespaces)
        value: []
        #value:
        #  - my-pod-default

      ################################################################
      # Environment
      #
      # NOTE:
      #  - these configs are only used by the ROK "flavor" of the UI
      ################################################################
      environment:
        readOnly: false
        value: {}
  controller:
    enabled: true
    image:
      repository: kubeflownotebookswg/notebook-controller
      registryOverwrite:
      tagOverwrite:
      pullPolicyOverwrite:
    resources:
      {}
      # limits:
      #   cpu: 100m
      #   memory: 128Mi
      # requests:
      #   cpu: 100m
      #   memory: 128Mi
    service:
      create: true
      annotations:
      type: ClusterIP
    autoscaling:
      # If autoscaling is disabled, replica count for a component is equal to minReplicas.
      enabled:
      minReplicas:
      maxReplicas:
      targetCPUUtilizationPercentage:
      targetMemoryUtilizationPercentage:
    podDisruptionBudget: {}
    rbac:
      create: true
    serviceAccount:
      create: true
      name:
      annotations:
    nodeSelector:
    tolerations:
    affinity:
    topologySpreadConstraints:
    containerSecurityContext:
    config:
      culling:
        enabled: false
        idleTimeMinutes: 1440
        idleCheckPeriodMinutes: 1
  volumesWebApp:
    enabled: true
    image:
      repository: kubeflownotebookswg/volumes-web-app
      registryOverwrite:
      tagOverwrite:
      pullPolicyOverwrite:
    resources:
      {}
      # limits:
      #   cpu: 100m
      #   memory: 128Mi
      # requests:
      #   cpu: 100m
      #   memory: 128Mi
    service:
      create: true
      annotations:
      type: ClusterIP
    autoscaling:
      # If autoscaling is disabled, replica count for a component is equal to minReplicas.
      enabled:
      minReplicas:
      maxReplicas:
      targetCPUUtilizationPercentage:
      targetMemoryUtilizationPercentage:
    podDisruptionBudget: {}
    rbac:
      create: true
    serviceAccount:
      create: true
      name:
      annotations:
    nodeSelector:
    tolerations:
    affinity:
    topologySpreadConstraints:
    containerSecurityContext:
    config:
      urlPrefix: /volumes
      secureCookies: true
      viewer:
        image:
          repository: filebrowser
          registryOverwrite: filebrowser
          tagOverwrite: v2.23.0
        serviceAccountName: default-editor
  pvcviewerController:
    enabled: true
    manager:
      image:
        repository: kubeflownotebookswg/pvcviewer-controller
        registryOverwrite:
        tagOverwrite:
        pullPolicyOverwrite:
      service:
        create: true
        annotations:
        type: ClusterIP
      resources:
        {}
        # limits:
        #   cpu: 500m
        #   memory: 128Mi
        # requests:
        #   cpu: 10m
        #   memory: 64Mi
      containerSecurityContext:
        allowPrivilegeEscalation: false
        capabilities:
          drop:
          - ALL
    kubeRbacProxy:
      image:
        repository: kubebuilder/kube-rbac-proxy
        registryOverwrite: gcr.io
        tagOverwrite: v0.13.1
        pullPolicyOverwrite:
      service:
        create: true
        annotations:
        type: ClusterIP
      resources:
        {}
        # limits:
        #   cpu: 500m
        #   memory: 128Mi
        # requests:
        #   cpu: 5m
        #   memory: 64Mi
      containerSecurityContext:
        allowPrivilegeEscalation: false
        capabilities:
          drop:
          - ALL
    autoscaling:
      # If autoscaling is disabled, replica count for a component is equal to minReplicas.
      enabled:
      minReplicas:
      maxReplicas:
      targetCPUUtilizationPercentage:
      targetMemoryUtilizationPercentage:
    podDisruptionBudget: {}
    rbac:
      create: true
    serviceAccount:
      create: true
      name:
      annotations:
    nodeSelector:
    tolerations:
    affinity:
      nodeAffinity:
        requiredDuringSchedulingIgnoredDuringExecution:
          nodeSelectorTerms:
          - matchExpressions:
            - key: kubernetes.io/arch
              operator: In
              values:
              - amd64
              - arm64
              - ppc64le
              - s390x
            - key: kubernetes.io/os
              operator: In
              values:
              - linux
    topologySpreadConstraints:
    terminationGracePeriodSeconds: 10
    securityContext:
      runAsNonRoot: true
      seccompProfile:
        type: RuntimeDefault

profilesController:
  enabled: true
  kfam:
    image:
      repository: kubeflownotebookswg/kfam
      registryOverwrite:
      tagOverwrite:
      pullPolicyOverwrite:
    service:
      create: true
      annotations:
      type: ClusterIP
    config:
      urlPrefix: /kfam
  manager:
    image:
      repository: kubeflownotebookswg/profile-controller
      registryOverwrite:
      tagOverwrite:
      pullPolicyOverwrite:
    resources:
      {}
      # limits:
      #   cpu: 100m
      #   memory: 128Mi
      # requests:
      #   cpu: 100m
      #   memory: 128Mi
  autoscaling:
    # If autoscaling is disabled, replica count for a component is equal to minReplicas.
    enabled:
    minReplicas:
    maxReplicas:
    targetCPUUtilizationPercentage:
    targetMemoryUtilizationPercentage:
  podDisruptionBudget: {}
  rbac:
    create: true
  serviceAccount:
    create: true
    name:
    annotations:
  nodeSelector:
  tolerations:
  affinity:
  topologySpreadConstraints:
  containerSecurityContext:
  config:
    admin:
    workloadIdentity:
    defaultNamespaceLabels:
      # Below is a list of labels to be set by default.
      #
      # To add a namespace label, use `key: 'value'`, for example:
      # istio.io/rev: 'asm-191-1'
      #
      # To remove a namespace label, use `key: ''`. For example:
      # istio-injection: ''
      #
      # Profile controller will not replace a namespace label if its key already
      # exists. If you want to override the value of a previously applied label, you
      # need to:
      # 1. Remove the label by using `key: ''` and deploy.
      # 2. Add the label by using `key: 'value'` and deploy.
      #
      katib.kubeflow.org/metrics-collector-injection: "enabled"
      serving.kubeflow.org/inferenceservice: "enabled"
      pipelines.kubeflow.org/enabled: "true"
      app.kubernetes.io/part-of: "kubeflow-profile"
    extraNamespaceLabels:



# TODO: verify patches in apps/pipeline/upstream/base/installs/multi-user
pipelines:
  enabled: true
  # NOTE: The pipelines do not use the '.Values.defaults.image' values because
  # the container images are stored in a different registry.
  image:
    registry: gcr.io/ml-pipeline
    tag: 2.0.1
    pullPolicy: IfNotPresent
  config:
    # If this is empty, the kfp backend will automatically configure that with:
    # "minio://mlpipeline/v2/artifacts"
    # Please see the following links for referece:
    # * <=2.1.0: https://github.com/kubeflow/pipelines/blob/2.1.0/backend/src/v2/config/env.go#L33
    # * >=2.2.0: https://github.com/kubeflow/pipelines/blob/2.2.0/backend/src/v2/config/env.go#L36
    #
    # If we want to use s3, we should configure this with something similar to:
    #   s3://mlpipeline/v2/artifacts
    #
    # In 2.2.0 it's also possible to define bucket 'providers', which can be minio, s3 or gcs:
    # * https://github.com/kubeflow/pipelines/blob/2.2.0/backend/src/v2/config/env.go#L45
    # * https://github.com/kubeflow/pipelines/blob/2.2.0/backend/src/v2/config/env.go#L151
    # * https://github.com/kubeflow/pipelines/blob/2.2.0/backend/src/v2/config/s3.go#L24
    defaultPipelineRoot: ""

    objectStore:
      # The Secret Name 'mlpipeline-minio-artifact' is currently hardcoded:
      # * <=2.1.0:
      #   https://github.com/kubeflow/pipelines/blob/2.1.0/backend/src/v2/objectstore/object_store.go#L292
      # * >=2.2.0 (state as of 2nd May 2024)
      #   https://github.com/kubeflow/pipelines/blob/2.2.0/backend/src/v2/config/env.go#L39
      #
      # It's only possible to use either nil or 'mlpipeline-minio-artifact' for
      # * .Values.pipelines.config.objectStore.existingSecretName
      # * .Values.pipelines.config.objectStore.accessKey.secretKeyRef.name
      # * .Values.pipelines.config.objectStore.secretAccessKey.secretKeyRef.name
      #
      # If the Secret Name is not provided in neither of the following, it will
      # be created with plaintext values for compatibility:
      # * .Values.pipelines.config.objectStore.existingSecretName
      # * .Values.pipelines.config.objectStore.accessKey.secretKeyRef.name
      # * .Values.pipelines.config.objectStore.secretAccessKey.secretKeyRef.name
      existingSecretName:
      accessKey:
        value: minio
        secretKeyRef:
          name:
          # The Secret Key 'accesskey' is currently hardcoded:
          # https://github.com/kubeflow/pipelines/blob/2.1.0/backend/src/v2/objectstore/object_store.go#L324
          # https://github.com/kubeflow/pipelines/blob/2.2.0/backend/src/v2/config/env.go#L42
          key: accesskey
      secretAccessKey:
        value: minio123
        secretKeyRef:
          name:
          # The Secret Key 'secretkey' is currently hardcoded:
          # https://github.com/kubeflow/pipelines/blob/2.1.0/backend/src/v2/objectstore/object_store.go#L325
          # https://github.com/kubeflow/pipelines/blob/2.2.0/backend/src/v2/config/env.go#L41
          key: secretkey
      host:
        value: minio
        secretKeyRef:
          name:
          key: host
      port:
        value: 9000
        secretKeyRef:
          name:
          key: port
      region:
        value:
        secretKeyRef:
          name:
          key: region
      secure:
        value: false
        secretKeyRef:
          name:
          key: secure
      bucketName:
        value: mlpipeline
        secretKeyRef:
          name:
          key: bucketName

    db:
      existingSecretName:
      user:
        value: root
        secretKeyRef:
          name:
          key: username
      password:
        value: mysql1234
        secretKeyRef:
          name:
          key: password
      host:
        value: mysql
        secretKeyRef:
          name:
          key: host
      port:
        value: 3306
        secretKeyRef:
          name:
          key: port
      mlmdDatabaseName:
        value: metadb
        secretKeyRef:
          name:
          key: mlmdDatabaseName
      pipelineDatabaseName:
        value: mlpipeline
        secretKeyRef:
          name:
          key: pipelineDatabaseName
      cacheDatabaseName:
        value: cachedb
        secretKeyRef:
          name:
          key: cacheDatabaseName
      driver:
        value: mysql
        secretKeyRef:
          name:
          key: driver
      conMaxLifetime:
        value: 120s
        secretKeyRef:
          name:
          key: conMaxLifetime

  # TODO: cache looks like it's missing a lot of stuff...
  cache:
    enabled: true
    image:
      repository: cache-server
      registryOverwrite:
      tagOverwrite:
      pullPolicyOverwrite:
    resources:
      # requests:
      #   cpu:
      #   memory:
      # limits:
      #   cpu:
      #   memory:
    service:
      create: true
      annotations:
      type: ClusterIP
      # TODO: investigate if exposing port config to all services makes sense.
      port: 8443
    autoscaling:
      # If autoscaling is disabled, replica count for a component is equal to minReplicas.
      # TODO: add PDB to all deployments.
      enabled:
      minReplicas:
      maxReplicas:
      targetCPUUtilizationPercentage:
      targetMemoryUtilizationPercentage:
    podDisruptionBudget: {}
    rbac:
      create: true
    serviceAccount:
      create: true
      name:
      annotations:
    nodeSelector:
    tolerations:
    affinity:
    topologySpreadConstraints:
    containerSecurityContext:
    config:
      ## defaultCacheStaleness and maximumCacheStaleness configures caching according to
      ## https://www.kubeflow.org/docs/components/pipelines/overview/caching/ and
      ## https://www.kubeflow.org/docs/components/pipelines/overview/caching-v2/.
      ## This value is used if the user did not set a value in the pipeline.
      ## defaultCacheStaleness: "P7D"
      ## maximumCacheStaleness: "P30D"
      defaultCacheStaleness: ""
      maximumCacheStaleness: ""
      ## ConMaxLifeTime will set the connection max lifetime for MySQL
      ## this is very important to setup when using external databases.
      ## See this issue for more details: https://github.com/kubeflow/pipelines/issues/5329
      ## Note: this value should be a string that can be parsed by `time.ParseDuration`.
      ## If this value doesn't include a unit abbreviation, the units will be assumed
      ## to be nanoseconds.
      conMaxLifeTime: "120s"
      ## cacheImage is the image that the mutating webhook will use to patch
      ## cached steps with. Will be used to echo a message announcing that
      ## the cached step result will be used. If not set it will default to
      ## 'gcr.io/google-containers/busybox'
      cacheImage: gcr.io/google-containers/busybox
      ## cacheNodeRestrictions the dummy container running if output is cached
      ## will run with the same affinity and node selector as the default pipeline
      ## step. This is defaulted to 'false' to allow the pod to be scheduled on
      ## any node and avoid defaulting to specific nodes. Allowed values are:
      ## 'false' and 'true'.
      cacheNodeRestrictions: "false"

  # ---

  mlPipeline:  # aka api-server
    enabled: true
    image:
      repository: api-server
      registryOverwrite:
      tagOverwrite:
      pullPolicyOverwrite:
    resources:
      requests:
        cpu: 250m
        memory: 500Mi
      # limits:
      #   cpu: 500m
      #   memory: 1024Mi
    service:
      create: true
      annotations:
      type: ClusterIP
    autoscaling:
      # If autoscaling is disabled, replica count for a component is equal to minReplicas.
      enabled:
      minReplicas:
      maxReplicas:
      targetCPUUtilizationPercentage:
      targetMemoryUtilizationPercentage:
    podDisruptionBudget: {}
    rbac:
      create: true
    serviceAccount:
      create: true
      name:
      annotations:
    nodeSelector:
    tolerations:
    affinity:
    topologySpreadConstraints:
    containerSecurityContext:
    config:
      # WARNING: currently the secrets are provided with direct values
      # to the deployment envs. This should be later improved to accept
      # existing Secrets and existing ConfigMap.
      #
      # always use KF Pipeline latest version?
      autoUpdatePipelineDefaultVersion: true

  persistenceAgent:
    enabled: true
    image:
      repository: persistenceagent
      registryOverwrite:
      tagOverwrite:
      pullPolicyOverwrite:
    resources:
      requests:
        cpu: 120m
        memory: 500Mi
      # limits:
      #   cpu: 500m
      #   memory: 1024Mi
    service:
      create: true
      annotations:
      type: ClusterIP
    autoscaling:
      # If autoscaling is disabled, replica count for a component is equal to minReplicas.
      enabled:
      minReplicas:
      maxReplicas:
      targetCPUUtilizationPercentage:
      targetMemoryUtilizationPercentage:
    podDisruptionBudget: {}
    rbac:
      create: true
    serviceAccount:
      create: true
      name:
      annotations:
    nodeSelector:
    tolerations:
    affinity:
    topologySpreadConstraints:
    containerSecurityContext:
    config:
      ttlSecondsAfterWorkflowFinish: 86400
      numWorkers: 2

  scheduledWorkflow:
    enabled: true
    image:
      repository: scheduledworkflow
      registryOverwrite:
      tagOverwrite:
      pullPolicyOverwrite:
    resources:
      # requests:
      #   cpu: 250m
      #   memory: 500Mi
      # limits:
      #   cpu: 500m
      #   memory: 1024Mi
    service:
      create: true
      annotations:
      type: ClusterIP
    autoscaling:
      # If autoscaling is disabled, replica count for a component is equal to minReplicas.
      enabled:
      minReplicas:
      maxReplicas:
      targetCPUUtilizationPercentage:
      targetMemoryUtilizationPercentage:
    podDisruptionBudget: {}
    rbac:
      create: true
    serviceAccount:
      create: true
      name:
      annotations:
    nodeSelector:
    tolerations:
    affinity:
    topologySpreadConstraints:
    containerSecurityContext:
    config:
      cronScheduleTimezone: "UTC"

  ui:
    enabled: true
    image:
      repository: frontend
      registryOverwrite:
      tagOverwrite:
      pullPolicyOverwrite:
    resources:
      requests:
        cpu: 10m
        memory: 70Mi
      # limits:
      #   cpu: 500m
      #   memory: 1024Mi
    service:
      create: true
      annotations:
      type: ClusterIP
    autoscaling:
      # If autoscaling is disabled, replica count for a component is equal to minReplicas.
      enabled:
      minReplicas:
      maxReplicas:
      targetCPUUtilizationPercentage:
      targetMemoryUtilizationPercentage:
    podDisruptionBudget: {}
    rbac:
      create: true
    serviceAccount:
      create: true
      name:
      annotations:
    nodeSelector:
    tolerations:
    affinity:
    topologySpreadConstraints:
    containerSecurityContext:
    config:
      # Note from apps/pipeline/upstream/base/installs/multi-user/pipelines-ui/configmap-patch.yaml
      # Temporary workarounds:
      # 1. Using default-editor because default-viewer isn't bound to workload identity
      viewerPodServiceAccountName: default-editor
      allowCustomVisualizations: true
      urlPrefix: /pipeline

  viewerCrd:
    enabled: true
    image:
      repository: viewer-crd-controller
      registryOverwrite:
      tagOverwrite:
      pullPolicyOverwrite:
    resources:
      # requests:
      #   cpu:
      #   memory:
      # limits:
      #   cpu:
      #   memory:
    service:
      create: true
      annotations:
      type: ClusterIP
    autoscaling:
      # If autoscaling is disabled, replica count for a component is equal to minReplicas.
      enabled:
      minReplicas:
      maxReplicas:
      targetCPUUtilizationPercentage:
      targetMemoryUtilizationPercentage:
    podDisruptionBudget: {}
    rbac:
      create: true
    serviceAccount:
      create: true
      name:
      annotations:
    nodeSelector:
    tolerations:
    affinity:
    topologySpreadConstraints:
    containerSecurityContext:
    config:
      maxNumViewers: 50

  metadataWriter:
    enabled: true
    image:
      repository: metadata-writer
      registryOverwrite:
      tagOverwrite:
      pullPolicyOverwrite:
    resources:
      # requests:
      #   cpu:
      #   memory:
      # limits:
      #   cpu:
      #   memory:
    service:
      create: true
      annotations:
      type: ClusterIP
    autoscaling:
      # If autoscaling is disabled, replica count for a component is equal to minReplicas.
      enabled:
      minReplicas:
      maxReplicas:
      targetCPUUtilizationPercentage:
      targetMemoryUtilizationPercentage:
    podDisruptionBudget: {}
    rbac:
      create: true
    serviceAccount:
      create: true
      name:
      annotations:
    nodeSelector:
    tolerations:
    affinity:
    topologySpreadConstraints:
    containerSecurityContext:
    config:

  # NOTE: defines istio sidecar injection but it doesn't work
  # because it's in an annotation, not pod label.
  metadataEnvoy:
    enabled: true
    image:
      repository: metadata-envoy
      registryOverwrite:
      tagOverwrite:
      pullPolicyOverwrite:
    resources:
      # requests:
      #   cpu:
      #   memory:
      # limits:
      #   cpu:
      #   memory:
    service:
      create: true
      annotations:
      type: ClusterIP
    autoscaling:
      # If autoscaling is disabled, replica count for a component is equal to minReplicas.
      # TODO: add PDB to all deployments.
      enabled:
      minReplicas:
      maxReplicas:
      targetCPUUtilizationPercentage:
      targetMemoryUtilizationPercentage:
    podDisruptionBudget: {}
    # NOTE: metadata-envoy doesn't define any RBAC.
    # rbac:
    #   create: true
    #   serviceAccount:
    #     create: true
    #     name:
    #     annotations:
    serviceAccount:
      create: false
      name:
      annotations:
    nodeSelector:
    tolerations:
    affinity:
    topologySpreadConstraints:
    containerSecurityContext:
    config:

  metadataGrpcServer:
    enabled: true
    image:
      registryOverwrite: gcr.io/tfx-oss-public
      repository: ml_metadata_store_server
      tagOverwrite: 1.5.0
      pullPolicyOverwrite:
    resources:
      # requests:
      #   cpu:
      #   memory:
      # limits:
      #   cpu:
      #   memory:
    service:
      create: true
      annotations:
      type: ClusterIP
      # TODO: investigate if exposing port config to all services makes sense.
      port: 8080
    autoscaling:
      # If autoscaling is disabled, replica count for a component is equal to minReplicas.
      # TODO: add PDB to all deployments.
      enabled:
      minReplicas:
      maxReplicas:
      targetCPUUtilizationPercentage:
      targetMemoryUtilizationPercentage:
    podDisruptionBudget: {}
    # NOTE: metadata-envoy doesn't define any RBAC.
    # rbac:
    #   create: true
    #   serviceAccount:
    #     create: true
    #     name:
    #     annotations:
    serviceAccount:
      create: true
      name:
      annotations:
    nodeSelector:
    tolerations:
    affinity:
    topologySpreadConstraints:
    containerSecurityContext:
    config:
      urlPrefix: /ml_metadata

  visualization:
    enabled: true
    image:
      repository: visualization-server
      registryOverwrite:
      tagOverwrite:
      pullPolicyOverwrite:
    resources:
      requests:
        cpu: 30m
        memory: 500Mi
      # limits:
      #   cpu:
      #   memory:
    service:
      create: true
      annotations:
      type: ClusterIP
    autoscaling:
      # If autoscaling is disabled, replica count for a component is equal to minReplicas.
      enabled:
      minReplicas:
      maxReplicas:
      targetCPUUtilizationPercentage:
      targetMemoryUtilizationPercentage:
    podDisruptionBudget: {}
    rbac:
      create: true
    serviceAccount:
      create: true
      name:
      annotations:
    nodeSelector:
    tolerations:
    affinity:
    topologySpreadConstraints:
    containerSecurityContext:
    config:

  # This is metacontroller based implementation that creates instances of
  # * Secret/mlpipeline-minio-artifact
  # * Deployment/ml-pipeline-ui-artifact
  # * Service/ml-pipeline-ui-artifact
  # * Deployment/ml-pipeline-visualizationserver
  # * Service/ml-pipeline-visualizationserver
  # * ConfigMap/kfp-launcher
  # * ConfigMap/metadata-grpc-configmap
  # * AuthorizationPolicy/ml-pipeline-visualizationserver
  # * DestinationRule/ml-pipeline-visualizationserver
  profileController:
    enabled: true
    image:
      repository: python
      registryOverwrite: docker.io
      tagOverwrite: "3.7"
      pullPolicyOverwrite:
    resources:
      # requests:
      #   cpu:
      #   memory:
      # limits:
      #   cpu:
      #   memory:
    service:
      create: true
      annotations:
      type: ClusterIP
    autoscaling:
      # If autoscaling is disabled, replica count for a component is equal to minReplicas.
      enabled:
      minReplicas:
      maxReplicas:
      targetCPUUtilizationPercentage:
      targetMemoryUtilizationPercentage:
    podDisruptionBudget: {}
    rbac:
      create: false
    serviceAccount:
      create: false
      name:
      annotations:
    nodeSelector:
    tolerations:
    affinity:
    topologySpreadConstraints:
    containerSecurityContext:
    config:
      disableIstioSidecar: false

  # ---
  # TODO: check if this is used
  kfam:
    image:
      repository: kubeflownotebookswg/kfam
      registryOverwrite:
      tagOverwrite:
      pullPolicyOverwrite:
    service:
      create: true
      annotations:
      type: ClusterIP
    config:
      urlPrefix: /kfam
  manager:
    image:
      repository: kubeflownotebookswg/profile-controller
      registryOverwrite:
      tagOverwrite:
      pullPolicyOverwrite:
    resources:
      {}
      # limits:
      #   cpu: 100m
      #   memory: 128Mi
      # requests:
      #   cpu: 100m
      #   memory: 128Mi
  autoscaling:
    # If autoscaling is disabled, replica count for a component is equal to minReplicas.
    enabled:
    minReplicas:
    maxReplicas:
    targetCPUUtilizationPercentage:
    targetMemoryUtilizationPercentage:
  podDisruptionBudget: {}
  rbac:
    create: true
  serviceAccount:
    create: true
    name:
    annotations:
  nodeSelector:
  tolerations:
  affinity:
  topologySpreadConstraints:
  containerSecurityContext:

# if cert manager is not enabled, we have to use cache-deployer.
# We currently don't support deployments without cert-manager.
certManagerIntegration:
  enabled: true

istioIntegration:
  enabled: true
  authentication:
    enabled: true
    # host: kubeflow.<your domain>.com # Used to isolate istio-ingress/AuthorizationPolicy to kubeflow subdomain i.e. kubeflow.<your domain>.com
  envoyExtAuthzHttpExtensionProviderName: oauth2-proxy
  rootNamespace: istio-system
  ingressGatewayNamespace: istio-ingress
  # Required for KF Profiles Controller to configure
  # correct AuthorizationPolicy principal.
  ingressGatewayServiceAccountName: istio-ingressgateway
  # one of ['ingressgateway', 'granular']
  # * 'ingressgateway' will deploy one AuthorizationPolicy in the namespace where
  #    istio ingress gateway Pod is being deployed.
  # * 'granular' will deploy multiple AuthorizationPolicies with CUSTOM action using auth provider,
  #   each for component that requires user id. This is an alternative way of setting authentication
  #   with istio. 'granular' is more secure but more complex.
  #   If you want to use 'granular', please also use the 'profile' Helm Chart in
  #   the same directory as 'kubeflow' Helm Chart which is already compliant
  #   with the 'granular' authorizationMode.
  authorizationMode: ingressgateway
  m2m:
    enabled: true
    # This will create CRB allowing access to
    # https://kubernetes.default.svc.cluster.local/.well-known/openid-configuration
    inCluster: true
    userClaim: sub
    issuer: https://kubernetes.default.svc.cluster.local
    selfSigned:
      autoJwksDiscovery: true
      jwks:
  userAuth:
    userClaim: email
    issuer: http://dex.dex.svc.cluster.local:5556/dex
  gateway:
    name: kubeflow-gateway
    selector:
      istio: ingressgateway
    # TODO: check if this is used
    servers:
      - hosts:
          - "*"
        port:
          number: 80
          name: http
          protocol: HTTP

# Both .Values.dexIntegration.enabled and .Values.istioIntegration.enabled has
# to be set to a boolean 'true' in order to create required dex integration
# resources.

# Automatically creates Istio VirtualService or Ingress objects.
dexIntegration:
  enabled: true
  svc:
    name: dex
    port: 5556
    namespace: dex

  # one of: 'internal', 'external'
  # * internal - the in-kubernetes svc address will be used as the dex IdP
  #              Issuer address.
  #   example: dex.dex.svc.cluster.local
  # * external - the .Values.dexIntegration.host will be used as the dex IdP
  #              Issuer address.
  #   example: dex.example.com
  # Currently only 'internal' is supported.
  integrationType: internal

  # One of: 'istio', 'ingress'.
  # Currently only 'istio' is supported.
  integrationMode: istio

  # 'host' must be set if .Values.dexIntegration.integrationType: external
  host:

  # If .Values.dexIntegration.integrationType: internal, dex IdP will be
  # available under this relative URL Prefix.
  urlPrefix: /dex

  integrationModeConfig:
    istio:
    ingress:
      class:
      annotations:

auth:
  userHeaderName: kubeflow-userid
  userIdPrefix: ""

clusterDomain: cluster.local

# apiVersion: v1
# data:
#   ConMaxLifeTime: 120s
#   DEFAULT_CACHE_STALENESS: ""
#   MAXIMUM_CACHE_STALENESS: ""
#   appName: pipeline
#   appVersion: 2.0.1
#   autoUpdatePipelineDefaultVersion: "true"
#   bucketName: mlpipeline
#   cacheDb: cachedb
#   cacheImage: gcr.io/google-containers/busybox
#   cacheNodeRestrictions: "false"
#   cronScheduleTimezone: UTC
#   dbHost: mysql
#   dbPort: "3306"
#   defaultPipelineRoot: ""
#   mlmdDb: metadb
#   pipelineDb: mlpipeline
#   warning: |
#     1. Do not use kubectl to edit this configmap, because some values are used
#     during kustomize build. Instead, change the configmap and apply the entire
#     kustomize manifests again.
#     2. After updating the configmap, some deployments may need to be restarted
#     until the changes take effect. A quick way to restart all deployments in a
#     namespace: `kubectl rollout restart deployment -n <your-namespace>`.
# kind: ConfigMap
# metadata:
#   labels:
#     app.kubernetes.io/component: ml-pipeline
#     app.kubernetes.io/name: kubeflow-pipelines
#     application-crd-id: kubeflow-pipelines
#   name: pipeline-install-config
#   namespace: kubeflow
