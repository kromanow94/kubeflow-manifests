# TODO: add mysql in separate chart

# $ k get virtualservices.networking.istio.io -A
# NAMESPACE                   NAME                                            GATEWAYS                        HOSTS   AGE
# dex                         dex                                             ["kubeflow/kubeflow-gateway"]   ["*"]   18d
# kubeflow-user-example-com   notebook-kubeflow-user-example-com-prof-kleks   ["kubeflow/kubeflow-gateway"]   ["*"]   17d
# kubeflow                    centraldashboard                                ["kubeflow-gateway"]            ["*"]   18d
# kubeflow                    jupyter-web-app                                 ["kubeflow-gateway"]            ["*"]   18d
# kubeflow                    ml-pipeline-metadata-grpc-server                ["kubeflow-gateway"]            ["*"]   24m
# kubeflow                    ml-pipeline-ui                                  ["kubeflow-gateway"]            ["*"]   24m
# kubeflow                    profiles-controller-kfam                        ["kubeflow-gateway"]            ["*"]   18d

# $ k -n metacontroller logs pod/metacontroller-metacontroller-helm-0
# {"level":"error","ts":1708974250.5236855,"msg":"failed to sync Namespace 'istio-system': sync hook failed for Namespace /istio-system: sync hook failed: http error: Post \"http://ml-pipeline-profile-controller/sync\": dial tcp: lookup ml-pipeline-profile-controller on 172.20.0.10:53: no such host\n","stacktrace":"metacontroller/pkg/controller/composite.(*parentController).worker\n\t/go/src/metacontroller/pkg/controller/composite/controller.go:286\nk8s.io/apimachinery/pkg/util/wait.BackoffUntil.func1\n\t/go/pkg/mod/k8s.io/apimachinery@v0.23.5/pkg/util/wait/wait.go:155\nk8s.io/apimachinery/pkg/util/wait.BackoffUntil\n\t/go/pkg/mod/k8s.io/apimachinery@v0.23.5/pkg/util/wait/wait.go:156\nk8s.io/apimachinery/pkg/util/wait.JitterUntil\n\t/go/pkg/mod/k8s.io/apimachinery@v0.23.5/pkg/util/wait/wait.go:133\nk8s.io/apimachinery/pkg/util/wait.Until\n\t/go/pkg/mod/k8s.io/apimachinery@v0.23.5/pkg/util/wait/wait.go:90\nmetacontroller/pkg/controller/composite.(*parentController).Start.func1.1\n\t/go/src/metacontroller/pkg/controller/composite/controller.go:262"}

# This namespace allows you to define where the services will be installed into
# if not set then they will use the namespace of the release
# This is helpful when installing Kubeflow as a chart dependency (sub chart).
namespace: ""

# one of ['cluster', 'namespace']
# 'namespace' is not yet fully supported.
# Maybe rename to 'deploymentScope'?
deploymentMode: cluster

imagePullSecrets: []
nameOverride: ""
fullnameOverride: ""

defaults:
  image:
    registry: docker.io
    # tag: "latest"
    tag: v1.8.0
    pullPolicy: IfNotPresent
  autoscaling:
    # If autoscaling is disabled, replica count for a component is equal to minReplicas.
    enabled: false
    minReplicas: 1
    maxReplicas: 3
    targetCPUUtilizationPercentage: 80
    targetMemoryUtilizationPercentage: 80
  podDisruptionBudget: {}
  nodeSelector: {}
  tolerations: []
  affinity: {}
  topologySpreadConstraints:
  containerSecurityContext:

centraldashboard:
  enabled: true
  image:
    repository: kubeflownotebookswg/centraldashboard
    registryOverwrite:
    tagOverwrite:
    pullPolicyOverwrite:
  resources:
    {}
    # limits:
    #   cpu: 100m
    #   memory: 128Mi
    # requests:
    #   cpu: 100m
    #   memory: 128Mi
  service:
    create: true
    annotations:
    type: ClusterIP
  autoscaling:
    # If autoscaling is disabled, replica count for a component is equal to minReplicas.
    enabled:
    minReplicas:
    maxReplicas:
    targetCPUUtilizationPercentage:
    targetMemoryUtilizationPercentage:
  podDisruptionBudget: {}
  rbac:
    create: true
  serviceAccount:
    create: true
    name:
    annotations:
  nodeSelector:
  tolerations:
  affinity:
  topologySpreadConstraints:
  containerSecurityContext:
  config:
    # This enables the automatic profile creation.
    enableRegistrationFlow: false
    logoutURL: "/authservice/logout"
    forceIFrame: true
    links:
      externalLinks:
      menuLinks:
        - type: item
          link: /jupyter/
          text: Notebooks
          icon: book
        - type: item
          link: /tensorboards/
          text: Tensorboards
          icon: assessment
        - type: item
          link: /volumes/
          text: Volumes
          icon: device:storage
        - type: item
          link: /models/
          text: Endpoints
          icon: kubeflow:models
        - type: item
          link: /katib/
          text: Experiments (AutoML)
          icon: kubeflow:katib
        - type: item
          text: Experiments (KFP)
          link: /pipeline/#/experiments
          icon: done-all
        - type: item
          link: /pipeline/#/pipelines
          text: Pipelines
          icon: kubeflow:pipeline-centered
        - type: item
          link: /pipeline/#/runs
          text: Runs
          icon: maps:directions-run
        - type: item
          link: /pipeline/#/recurringruns
          text: Recurring Runs
          icon: device:access-alarm
        - type: item
          link: /pipeline/#/artifacts
          text: Artifacts
          icon: editor:bubble-chart
        - type: item
          link: /pipeline/#/executions
          text: Executions
          icon: av:play-arrow
      quickLinks:
        - text: Upload a pipeline
          desc: Pipelines
          link: /pipeline/
        - text: View all pipeline runs
          desc: Pipelines
          link: /pipeline/#/runs
        - text: Create a new Notebook server
          desc: Notebook Servers
          # NOTE(kromanow94): it's probably not needed to add namespace here...
          # at least in multi user mode.
          # TODO(kromanow94): check if this is needed...
          # link: /jupyter/new?namespace=kubeflow
          link: /jupyter/new
        - text: View Katib Experiments
          desc: Katib
          link: /katib/
      documentationItems:
        - text: Getting Started with Kubeflow
          desc: Get your machine-learning workflow up and running on Kubeflow
          link: https://www.kubeflow.org/docs/started/getting-started/
        - text: MiniKF
          desc: A fast and easy way to deploy Kubeflow locally
          link: https://www.kubeflow.org/docs/distributions/minikf/
        - text: Microk8s for Kubeflow
          desc: Quickly get Kubeflow running locally on native hypervisors
          link: https://www.kubeflow.org/docs/distributions/microk8s/kubeflow-on-microk8s/
        - text: Kubeflow on GCP
          desc: Running Kubeflow on Kubernetes Engine and Google Cloud Platform
          link: https://www.kubeflow.org/docs/gke/
        - text: Kubeflow on AWS
          desc: Running Kubeflow on Elastic Container Service and Amazon Web Services
          link: https://www.kubeflow.org/docs/aws/
        - text: Requirements for Kubeflow
          desc: Get more detailed information about using Kubeflow and its components
          link: https://www.kubeflow.org/docs/started/requirements/

notebooks:
  enabled: true
  jupyterWebApp:
    enabled: true
    image:
      repository: kubeflownotebookswg/jupyter-web-app
      registryOverwrite:
      tagOverwrite:
      pullPolicyOverwrite:
    resources:
      {}
      # limits:
      #   cpu: 100m
      #   memory: 128Mi
      # requests:
      #   cpu: 100m
      #   memory: 128Mi
    service:
      create: true
      annotations:
      type: ClusterIP
    autoscaling:
      # If autoscaling is disabled, replica count for a component is equal to minReplicas.
      enabled:
      minReplicas:
      maxReplicas:
      targetCPUUtilizationPercentage:
      targetMemoryUtilizationPercentage:
    podDisruptionBudget: {}
    rbac:
      create: true
    serviceAccount:
      create: true
      name:
      annotations:
    nodeSelector:
    tolerations:
    affinity:
    topologySpreadConstraints:
    containerSecurityContext:
    # TODO: embed into config
    urlPrefix: /jupyter
    uiFlavor: default
    secureCookies: true
    logos:
      # if this is defined, the configmap with logos will not be created but
      # the one provided with customConfigMap will be used.
      customConfigMap:
      # if below values are defined, those will be used for the icons
      # instead of defaults
      icons:
        jupyterIconSvg:
        jupyterLabLogoSvg:
        groupOneIconSvg:
        groupOneLogoSvg:
        groupTwoIconSvg:
        groupTwoLogoSvg:
    spawnerFormDefaults:
      # --------------------------------------------------------------
      # Configuration file for the Kubeflow Notebooks UI.
      #
      # About the `readOnly` configs:
      #  - when `readOnly` is set to "true", the respective option
      #    will be disabled for users and only set by the admin
      #  - when 'readOnly' is missing, it defaults to 'false'
      # --------------------------------------------------------------

      ################################################################
      # Container Images
      ################################################################
      # if users can input custom images, or only select from dropdowns
      allowCustomImage: true

      # if the registry of the container image is hidden from display
      hideRegistry: true

      # if the tag of the container image is hidden from display
      hideTag: false

      # configs for the ImagePullPolicy
      imagePullPolicy:
        readOnly: false

        # the default ImagePullPolicy
        # (possible values: "Always", "IfNotPresent", "Never")
        value: IfNotPresent

      ################################################################
      # Jupyter-like Container Images
      #
      # NOTES:
      #  - the `image` section is used for "Jupyter-like" apps whose
      #    HTTP path is configured by the "NB_PREFIX" environment variable
      ################################################################
      image:
        # the default container image
        value: kubeflownotebookswg/jupyter-scipy:v1.8.0-rc.0

        # the list of available container images in the dropdown
        options:
          - kubeflownotebookswg/jupyter-scipy:v1.8.0-rc.0
          - kubeflownotebookswg/jupyter-pytorch-full:v1.8.0-rc.0
          - kubeflownotebookswg/jupyter-pytorch-cuda-full:v1.8.0-rc.0
          - kubeflownotebookswg/jupyter-tensorflow-full:v1.8.0-rc.0
          - kubeflownotebookswg/jupyter-tensorflow-cuda-full:v1.8.0-rc.0

      ################################################################
      # VSCode-like Container Images (Group 1)
      #
      # NOTES:
      #  - the `imageGroupOne` section is used for "VSCode-like" apps that
      #    expose themselves under the HTTP root path "/" and support path
      #    rewriting without breaking
      #  - the annotation `notebooks.kubeflow.org/http-rewrite-uri: "/"` is
      #    set on Notebooks spawned by this group, to make Istio rewrite
      #    the path of HTTP requests to the HTTP root
      ################################################################
      imageGroupOne:
        # the default container image
        value: kubeflownotebookswg/codeserver-python:v1.8.0-rc.0

        # the list of available container images in the dropdown
        options:
          - kubeflownotebookswg/codeserver-python:v1.8.0-rc.0

      ################################################################
      # RStudio-like Container Images (Group 2)
      #
      # NOTES:
      #  - the `imageGroupTwo` section is used for "RStudio-like" apps whose
      #    HTTP path is configured by the "X-RStudio-Root-Path" header
      #  - the annotation `notebooks.kubeflow.org/http-rewrite-uri: "/"` is
      #    set on Notebooks spawned by this group, to make Istio rewrite
      #    the path of HTTP requests to the HTTP root
      #  - the annotation `notebooks.kubeflow.org/http-headers-request-set` is
      #    set on Notebooks spawned by this group, such that Istio injects the
      #    "X-RStudio-Root-Path" header to all request
      ################################################################
      imageGroupTwo:
        # the default container image
        value: kubeflownotebookswg/rstudio-tidyverse:v1.8.0-rc.0

        # the list of available container images in the dropdown
        options:
          - kubeflownotebookswg/rstudio-tidyverse:v1.8.0-rc.0

      ################################################################
      # CPU Resources
      ################################################################
      cpu:
        readOnly: false

        # the default cpu request for the container
        value: "0.5"

        # a factor by which to multiply the CPU request calculate the cpu limit
        # (to disable cpu limits, set as "none")
        limitFactor: "1.2"

      ################################################################
      # Memory Resources
      ################################################################
      memory:
        readOnly: false

        # the default memory request for the container
        value: "1.0Gi"

        # a factor by which to multiply the memory request calculate the memory limit
        # (to disable memory limits, set as "none")
        limitFactor: "1.2"

      ################################################################
      # GPU/Device-Plugin Resources
      ################################################################
      gpus:
        readOnly: false

        # configs for gpu/device-plugin limits of the container
        # https://kubernetes.io/docs/tasks/manage-gpus/scheduling-gpus/#using-device-plugins
        value:
          # the `limitKey` of the default vendor
          # (to have no default, set as "")
          vendor: ""

          # the list of available vendors in the dropdown
          #  `limitsKey` - what will be set as the actual limit
          #  `uiName` - what will be displayed in the dropdown UI
          vendors: []
          #vendors:
          #  - limitsKey: "nvidia.com/gpu"
          #    uiName: "NVIDIA"
          #  - limitsKey: "amd.com/gpu"
          #    uiName: "AMD"

          # the default value of the limit
          # (possible values: "none", "1", "2", "4", "8")
          num: "none"

      ################################################################
      # Workspace Volumes
      ################################################################
      workspaceVolume:
        readOnly: false

        # the default workspace volume to be created and mounted
        # (to have no default, set `value: null`)
        value:
          mount: /home/jovyan

          # pvc configs for creating new workspace volumes
          # https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.24/#persistentvolumeclaim-v1-core
          newPvc:
            metadata:
              # "{notebook-name}" is replaced with the Notebook name
              name: "{notebook-name}-workspace"
            spec:
              #storageClassName: my-storage-class
              resources:
                requests:
                  storage: 5Gi
              accessModes:
                - ReadWriteOnce

      ################################################################
      # Data Volumes
      ################################################################
      dataVolumes:
        readOnly: false

        # a list of additional data volumes to be created and/or mounted
        value: []
        #value:
        #  - mount: /home/jovyan/datavol-1
        #    newPvc:
        #      metadata:
        #        name: "{notebook-name}-datavol-1"
        #      spec:
        #        resources:
        #          requests:
        #            storage: 5Gi
        #        accessModes:
        #          - ReadWriteOnce
        #
        #  - mount: /home/jovyan/datavol-1
        #    existingSource:
        #      persistentVolumeClaim:
        #        claimName: "test-pvc"

      ################################################################
      # Affinity
      ################################################################
      affinityConfig:
        readOnly: false

        # the `configKey` of the default affinity config
        # (to have no default, set as "")
        # (if `readOnly`, the default `value` will be the only accessible option)
        value: ""

        # the list of available affinity configs in the dropdown
        options: []
        #options:
        #  - configKey: "dedicated_node_per_notebook"
        #    displayName: "Dedicated Node Per Notebook"
        #    affinity:
        #      # Require a Node with label `lifecycle=kubeflow-notebook`
        #      nodeAffinity:
        #        requiredDuringSchedulingIgnoredDuringExecution:
        #          nodeSelectorTerms:
        #            - matchExpressions:
        #                - key: "lifecycle"
        #                  operator: "In"
        #                  values:
        #                    - "kubeflow-notebook"
        #
        #      # Require a Node WITHOUT an existing Pod having `notebook-name` label
        #      podAntiAffinity:
        #        requiredDuringSchedulingIgnoredDuringExecution:
        #          - labelSelector:
        #              matchExpressions:
        #                - key: "notebook-name"
        #                  operator: "Exists"
        #            topologyKey: "kubernetes.io/hostname"
        #            # WARNING: `namespaceSelector` is Beta in 1.22 and Stable in 1.24,
        #            #          setting to {} is required for affinity to work across Namespaces
        #            namespaceSelector: {}

      ################################################################
      # Tolerations
      ################################################################
      tolerationGroup:
        readOnly: false

        # the `groupKey` of the default toleration group
        # (to have no default, set as "")
        # (if `readOnly`, the default `value` will be the only accessible option)
        value: ""

        # the list of available toleration groups in the dropdown
        options: []
        #options:
        #  - groupKey: "group_1"
        #    displayName: "4 CPU 8Gb Mem at ~$X.XXX USD per day"
        #    tolerations:
        #      - key: "dedicated"
        #        operator: "Equal"
        #        value: "kubeflow-c5.xlarge"
        #        effect: "NoSchedule"
        #
        #  - groupKey: "group_2"
        #    displayName: "8 CPU 16Gb Mem at ~$X.XXX USD per day"
        #    tolerations:
        #      - key: "dedicated"
        #        operator: "Equal"
        #        value: "kubeflow-c5.2xlarge"
        #        effect: "NoSchedule"
        #
        #  - groupKey: "group_3"
        #    displayName: "16 CPU 32Gb Mem at ~$X.XXX USD per day"
        #    tolerations:
        #      - key: "dedicated"
        #        operator: "Equal"
        #        value: "kubeflow-c5.4xlarge"
        #        effect: "NoSchedule"
        #
        #  - groupKey: "group_4"
        #    displayName: "32 CPU 256Gb Mem at ~$X.XXX USD per day"
        #    tolerations:
        #      - key: "dedicated"
        #        operator: "Equal"
        #        value: "kubeflow-r5.8xlarge"
        #        effect: "NoSchedule"

      ################################################################
      # Shared Memory
      ################################################################
      shm:
        readOnly: false

        # the default state of the "Enable Shared Memory" toggle
        value: true

      ################################################################
      # PodDefaults
      ################################################################
      configurations:
        readOnly: false

        # the list of PodDefault names that are selected by default
        # (take care to ensure these PodDefaults exist in Profile Namespaces)
        value: []
        #value:
        #  - my-pod-default

      ################################################################
      # Environment
      #
      # NOTE:
      #  - these configs are only used by the ROK "flavor" of the UI
      ################################################################
      environment:
        readOnly: false
        value: {}
  controller:
    enabled: true
    image:
      repository: kubeflownotebookswg/notebook-controller
      registryOverwrite:
      tagOverwrite:
      pullPolicyOverwrite:
    resources:
      {}
      # limits:
      #   cpu: 100m
      #   memory: 128Mi
      # requests:
      #   cpu: 100m
      #   memory: 128Mi
    service:
      create: true
      annotations:
      type: ClusterIP
    autoscaling:
      # If autoscaling is disabled, replica count for a component is equal to minReplicas.
      enabled:
      minReplicas:
      maxReplicas:
      targetCPUUtilizationPercentage:
      targetMemoryUtilizationPercentage:
    podDisruptionBudget: {}
    rbac:
      create: true
    serviceAccount:
      create: true
      name:
      annotations:
    nodeSelector:
    tolerations:
    affinity:
    topologySpreadConstraints:
    containerSecurityContext:
    config:
      culling:
        enabled: false
        idleTimeMinutes: 1440
        idleCheckPeriodMinutes: 1

profilesController:
  enabled: true
  kfam:
    image:
      repository: kubeflownotebookswg/kfam
      registryOverwrite:
      tagOverwrite:
      pullPolicyOverwrite:
    service:
      create: true
      annotations:
      type: ClusterIP
    config:
      urlPrefix: /kfam
  manager:
    image:
      repository: kubeflownotebookswg/profile-controller
      registryOverwrite:
      tagOverwrite:
      pullPolicyOverwrite:
    resources:
      {}
      # limits:
      #   cpu: 100m
      #   memory: 128Mi
      # requests:
      #   cpu: 100m
      #   memory: 128Mi
  autoscaling:
    # If autoscaling is disabled, replica count for a component is equal to minReplicas.
    enabled:
    minReplicas:
    maxReplicas:
    targetCPUUtilizationPercentage:
    targetMemoryUtilizationPercentage:
  podDisruptionBudget: {}
  rbac:
    create: true
  serviceAccount:
    create: true
    name:
    annotations:
  nodeSelector:
  tolerations:
  affinity:
  topologySpreadConstraints:
  containerSecurityContext:
  config:
    admin:
    workloadIdentity:
    defaultNamespaceLabels:
      # Below is a list of labels to be set by default.
      #
      # To add a namespace label, use `key: 'value'`, for example:
      # istio.io/rev: 'asm-191-1'
      #
      # To remove a namespace label, use `key: ''`. For example:
      # istio-injection: ''
      #
      # Profile controller will not replace a namespace label if its key already
      # exists. If you want to override the value of a previously applied label, you
      # need to:
      # 1. Remove the label by using `key: ''` and deploy.
      # 2. Add the label by using `key: 'value'` and deploy.
      #
      katib.kubeflow.org/metrics-collector-injection: "enabled"
      serving.kubeflow.org/inferenceservice: "enabled"
      pipelines.kubeflow.org/enabled: "true"
      app.kubernetes.io/part-of: "kubeflow-profile"
    extraNamespaceLabels:


# TODO: verify patches in apps/pipeline/upstream/base/installs/multi-user
pipelines:
  enabled: true
  # NOTE: The pipelines do not use the '.Values.defaults.image' values because
  # the container images are stored in a different registry.
  image:
    registry: gcr.io/ml-pipeline
    tag: 2.0.1
    pullPolicy: IfNotPresent
  config:
    # S3 / minio
    objectStoreConfigSecure: false
    objectStoreConfigBucketname: mlpipeline
    objectStoreAccessKey: minio
    objectStoreSecretKey: minio123
    # DB
    dbHost: mysql
    dbPort: 3306
    dbConfigUser: root
    # dbConfigPassword: ""  # or "test" or b64(dGVzdA==)
    dbConfigPassword: mysql1234
    dbConfigConMaxLifetime: 120s
    dbConfigDriver: mysql
    pipelineDb: mlpipeline
    mlmdDb: metadb
    cacheDb: cachedb
    defaultPipelineRoot: ""

  # TODO: cache looks like it's missing a lot of stuff...
  cache:
    enabled: true
    image:
      repository: cache-server
      registryOverwrite:
      tagOverwrite:
      pullPolicyOverwrite:
    resources:
      # requests:
      #   cpu:
      #   memory:
      # limits:
      #   cpu:
      #   memory:
    service:
      create: true
      annotations:
      type: ClusterIP
      # TODO: investigate if exposing port config to all services makes sense.
      port: 8443
    autoscaling:
      # If autoscaling is disabled, replica count for a component is equal to minReplicas.
      # TODO: add PDB to all deployments.
      enabled:
      minReplicas:
      maxReplicas:
      targetCPUUtilizationPercentage:
      targetMemoryUtilizationPercentage:
    podDisruptionBudget: {}
    rbac:
      create: true
    serviceAccount:
      create: true
      name:
      annotations:
    nodeSelector:
    tolerations:
    affinity:
    topologySpreadConstraints:
    containerSecurityContext:
    config:
      ## defaultCacheStaleness and maximumCacheStaleness configures caching according to
      ## https://www.kubeflow.org/docs/components/pipelines/overview/caching/ and
      ## https://www.kubeflow.org/docs/components/pipelines/overview/caching-v2/.
      ## This value is used if the user did not set a value in the pipeline.
      ## defaultCacheStaleness: "P7D"
      ## maximumCacheStaleness: "P30D"
      defaultCacheStaleness: ""
      maximumCacheStaleness: ""
      ## ConMaxLifeTime will set the connection max lifetime for MySQL
      ## this is very important to setup when using external databases.
      ## See this issue for more details: https://github.com/kubeflow/pipelines/issues/5329
      ## Note: this value should be a string that can be parsed by `time.ParseDuration`.
      ## If this value doesn't include a unit abbreviation, the units will be assumed
      ## to be nanoseconds.
      conMaxLifeTime: "120s"
      ## cacheImage is the image that the mutating webhook will use to patch
      ## cached steps with. Will be used to echo a message announcing that
      ## the cached step result will be used. If not set it will default to
      ## 'gcr.io/google-containers/busybox'
      cacheImage: gcr.io/google-containers/busybox
      ## cacheNodeRestrictions the dummy container running if output is cached
      ## will run with the same affinity and node selector as the default pipeline
      ## step. This is defaulted to 'false' to allow the pod to be scheduled on
      ## any node and avoid defaulting to specific nodes. Allowed values are:
      ## 'false' and 'true'.
      cacheNodeRestrictions: "false"

  # ---

  mlPipeline:  # aka api-server
    enabled: true
    image:
      repository: api-server
      registryOverwrite:
      tagOverwrite:
      pullPolicyOverwrite:
    resources:
      requests:
        cpu: 250m
        memory: 500Mi
      # limits:
      #   cpu: 500m
      #   memory: 1024Mi
    service:
      create: true
      annotations:
      type: ClusterIP
    autoscaling:
      # If autoscaling is disabled, replica count for a component is equal to minReplicas.
      enabled:
      minReplicas:
      maxReplicas:
      targetCPUUtilizationPercentage:
      targetMemoryUtilizationPercentage:
    podDisruptionBudget: {}
    rbac:
      create: true
    serviceAccount:
      create: true
      name:
      annotations:
    nodeSelector:
    tolerations:
    affinity:
    topologySpreadConstraints:
    containerSecurityContext:
    config:
      # WARNING: currently the secrets are provided with direct values
      # to the deployment envs. This should be later improved to accept
      # existing Secrets and existing ConfigMap.
      #
      # always use KF Pipeline latest version?
      autoUpdatePipelineDefaultVersion: true

  persistenceAgent:
    enabled: true
    image:
      repository: persistenceagent
      registryOverwrite:
      tagOverwrite:
      pullPolicyOverwrite:
    resources:
      requests:
        cpu: 120m
        memory: 500Mi
      # limits:
      #   cpu: 500m
      #   memory: 1024Mi
    service:
      create: true
      annotations:
      type: ClusterIP
    autoscaling:
      # If autoscaling is disabled, replica count for a component is equal to minReplicas.
      enabled:
      minReplicas:
      maxReplicas:
      targetCPUUtilizationPercentage:
      targetMemoryUtilizationPercentage:
    podDisruptionBudget: {}
    rbac:
      create: true
    serviceAccount:
      create: true
      name:
      annotations:
    nodeSelector:
    tolerations:
    affinity:
    topologySpreadConstraints:
    containerSecurityContext:
    config:
      ttlSecondsAfterWorkflowFinish: 86400
      numWorkers: 2

  scheduledWorkflow:
    enabled: true
    image:
      repository: scheduledworkflow
      registryOverwrite:
      tagOverwrite:
      pullPolicyOverwrite:
    resources:
      # requests:
      #   cpu: 250m
      #   memory: 500Mi
      # limits:
      #   cpu: 500m
      #   memory: 1024Mi
    service:
      create: true
      annotations:
      type: ClusterIP
    autoscaling:
      # If autoscaling is disabled, replica count for a component is equal to minReplicas.
      enabled:
      minReplicas:
      maxReplicas:
      targetCPUUtilizationPercentage:
      targetMemoryUtilizationPercentage:
    podDisruptionBudget: {}
    rbac:
      create: true
    serviceAccount:
      create: true
      name:
      annotations:
    nodeSelector:
    tolerations:
    affinity:
    topologySpreadConstraints:
    containerSecurityContext:
    config:
      cronScheduleTimezone: "UTC"

  ui:
    enabled: true
    image:
      repository: frontend
      registryOverwrite:
      tagOverwrite:
      pullPolicyOverwrite:
    resources:
      requests:
        cpu: 10m
        memory: 70Mi
      # limits:
      #   cpu: 500m
      #   memory: 1024Mi
    service:
      create: true
      annotations:
      type: ClusterIP
    autoscaling:
      # If autoscaling is disabled, replica count for a component is equal to minReplicas.
      enabled:
      minReplicas:
      maxReplicas:
      targetCPUUtilizationPercentage:
      targetMemoryUtilizationPercentage:
    podDisruptionBudget: {}
    rbac:
      create: true
    serviceAccount:
      create: true
      name:
      annotations:
    nodeSelector:
    tolerations:
    affinity:
    topologySpreadConstraints:
    containerSecurityContext:
    config:
      # Note from apps/pipeline/upstream/base/installs/multi-user/pipelines-ui/configmap-patch.yaml
      # Temporary workarounds:
      # 1. Using default-editor because default-viewer isn't bound to workload identity
      viewerPodServiceAccountName: default-editor
      allowCustomVisualizations: true
      urlPrefix: /pipeline

  viewerCrd:
    enabled: true
    image:
      repository: viewer-crd-controller
      registryOverwrite:
      tagOverwrite:
      pullPolicyOverwrite:
    resources:
      # requests:
      #   cpu:
      #   memory:
      # limits:
      #   cpu:
      #   memory:
    service:
      create: true
      annotations:
      type: ClusterIP
    autoscaling:
      # If autoscaling is disabled, replica count for a component is equal to minReplicas.
      enabled:
      minReplicas:
      maxReplicas:
      targetCPUUtilizationPercentage:
      targetMemoryUtilizationPercentage:
    podDisruptionBudget: {}
    rbac:
      create: true
    serviceAccount:
      create: true
      name:
      annotations:
    nodeSelector:
    tolerations:
    affinity:
    topologySpreadConstraints:
    containerSecurityContext:
    config:
      maxNumViewers: 50

  metadataWriter:
    enabled: true
    image:
      repository: metadata-writer
      registryOverwrite:
      tagOverwrite:
      pullPolicyOverwrite:
    resources:
      # requests:
      #   cpu:
      #   memory:
      # limits:
      #   cpu:
      #   memory:
    service:
      create: true
      annotations:
      type: ClusterIP
    autoscaling:
      # If autoscaling is disabled, replica count for a component is equal to minReplicas.
      enabled:
      minReplicas:
      maxReplicas:
      targetCPUUtilizationPercentage:
      targetMemoryUtilizationPercentage:
    podDisruptionBudget: {}
    rbac:
      create: true
    serviceAccount:
      create: true
      name:
      annotations:
    nodeSelector:
    tolerations:
    affinity:
    topologySpreadConstraints:
    containerSecurityContext:
    config:

  # NOTE: defines istio sidecar injection but it doesn't work
  # because it's in an annotation, not pod label.
  metadataEnvoy:
    enabled: true
    image:
      repository: metadata-envoy
      registryOverwrite:
      tagOverwrite:
      pullPolicyOverwrite:
    resources:
      # requests:
      #   cpu:
      #   memory:
      # limits:
      #   cpu:
      #   memory:
    service:
      create: true
      annotations:
      type: ClusterIP
    autoscaling:
      # If autoscaling is disabled, replica count for a component is equal to minReplicas.
      # TODO: add PDB to all deployments.
      enabled:
      minReplicas:
      maxReplicas:
      targetCPUUtilizationPercentage:
      targetMemoryUtilizationPercentage:
    podDisruptionBudget: {}
    # NOTE: metadata-envoy doesn't define any RBAC.
    # rbac:
    #   create: true
    #   serviceAccount:
    #     create: true
    #     name:
    #     annotations:
    serviceAccount:
      create: false
      name:
      annotations:
    nodeSelector:
    tolerations:
    affinity:
    topologySpreadConstraints:
    containerSecurityContext:
    config:

  metadataGrpcServer:
    enabled: true
    image:
      registryOverwrite: gcr.io/tfx-oss-public
      repository: ml_metadata_store_server
      tagOverwrite: 1.5.0
      pullPolicyOverwrite:
    resources:
      # requests:
      #   cpu:
      #   memory:
      # limits:
      #   cpu:
      #   memory:
    service:
      create: true
      annotations:
      type: ClusterIP
      # TODO: investigate if exposing port config to all services makes sense.
      port: 8080
    autoscaling:
      # If autoscaling is disabled, replica count for a component is equal to minReplicas.
      # TODO: add PDB to all deployments.
      enabled:
      minReplicas:
      maxReplicas:
      targetCPUUtilizationPercentage:
      targetMemoryUtilizationPercentage:
    podDisruptionBudget: {}
    # NOTE: metadata-envoy doesn't define any RBAC.
    # rbac:
    #   create: true
    #   serviceAccount:
    #     create: true
    #     name:
    #     annotations:
    serviceAccount:
      create: true
      name:
      annotations:
    nodeSelector:
    tolerations:
    affinity:
    topologySpreadConstraints:
    containerSecurityContext:
    config:
      urlPrefix: /ml_metadata

  visualization:
    enabled: true
    image:
      repository: visualization-server
      registryOverwrite:
      tagOverwrite:
      pullPolicyOverwrite:
    resources:
      requests:
        cpu: 30m
        memory: 500Mi
      # limits:
      #   cpu:
      #   memory:
    service:
      create: true
      annotations:
      type: ClusterIP
    autoscaling:
      # If autoscaling is disabled, replica count for a component is equal to minReplicas.
      enabled:
      minReplicas:
      maxReplicas:
      targetCPUUtilizationPercentage:
      targetMemoryUtilizationPercentage:
    podDisruptionBudget: {}
    rbac:
      create: true
    serviceAccount:
      create: true
      name:
      annotations:
    nodeSelector:
    tolerations:
    affinity:
    topologySpreadConstraints:
    containerSecurityContext:
    config:

  # This is metacontroller based implementation that creates instances of
  # * Secret/mlpipeline-minio-artifact
  # * Deployment/ml-pipeline-ui-artifact
  # * Service/ml-pipeline-ui-artifact
  # * Deployment/ml-pipeline-visualizationserver
  # * Service/ml-pipeline-visualizationserver
  # * ConfigMap/kfp-launcher
  # * ConfigMap/metadata-grpc-configmap
  # * AuthorizationPolicy/ml-pipeline-visualizationserver
  # * DestinationRule/ml-pipeline-visualizationserver
  profileController:
    enabled: true
    image:
      repository: python
      registryOverwrite: docker.io
      tagOverwrite: "3.7"
      pullPolicyOverwrite:
    resources:
      # requests:
      #   cpu:
      #   memory:
      # limits:
      #   cpu:
      #   memory:
    service:
      create: true
      annotations:
      type: ClusterIP
    autoscaling:
      # If autoscaling is disabled, replica count for a component is equal to minReplicas.
      enabled:
      minReplicas:
      maxReplicas:
      targetCPUUtilizationPercentage:
      targetMemoryUtilizationPercentage:
    podDisruptionBudget: {}
    rbac:
      create: false
    serviceAccount:
      create: false
      name:
      annotations:
    nodeSelector:
    tolerations:
    affinity:
    topologySpreadConstraints:
    containerSecurityContext:
    config:
      disableIstioSidecar: false

  # ---
  # TODO: check if this is used
  kfam:
    image:
      repository: kubeflownotebookswg/kfam
      registryOverwrite:
      tagOverwrite:
      pullPolicyOverwrite:
    service:
      create: true
      annotations:
      type: ClusterIP
    config:
      urlPrefix: /kfam
  manager:
    image:
      repository: kubeflownotebookswg/profile-controller
      registryOverwrite:
      tagOverwrite:
      pullPolicyOverwrite:
    resources:
      {}
      # limits:
      #   cpu: 100m
      #   memory: 128Mi
      # requests:
      #   cpu: 100m
      #   memory: 128Mi
  autoscaling:
    # If autoscaling is disabled, replica count for a component is equal to minReplicas.
    enabled:
    minReplicas:
    maxReplicas:
    targetCPUUtilizationPercentage:
    targetMemoryUtilizationPercentage:
  podDisruptionBudget: {}
  rbac:
    create: true
  serviceAccount:
    create: true
    name:
    annotations:
  nodeSelector:
  tolerations:
  affinity:
  topologySpreadConstraints:
  containerSecurityContext:

# if cert manager is not enabled, we have to use cache-deployer.
# We currently don't support deployments without cert-manager.
certManagerIntegration:
  enabled: true

istioIntegration:
  enabled: true
  envoyExtAuthzHttpExtensionProviderName: oauth2-proxy
  rootNamespace: istio-system
  ingressGatewayNamespace: istio-ingress
  m2m:
    enabled: true
    # This will create CRB allowing access to
    # https://kubernetes.default.svc.cluster.local/.well-known/openid-configuration
    inCluster: true
    userClaim: sub
    issuer: https://kubernetes.default.svc.cluster.local
    selfSigned:
      # This is not yet fully supported.
      autoJwksDiscovery: false
      jwks:
  userAuth:
    userClaim: email
    issuer: http://dex.dex.svc.cluster.local:5556/dex
  gateway:
    name: kubeflow-gateway
    selector:
      istio: ingressgateway
    # TODO: check if this is used
    servers:
      - hosts:
          - "*"
        port:
          number: 80
          name: http
          protocol: HTTP

# Both .Values.dexIntegration.enabled and .Values.istioIntegration.enabled has
# to be set to a boolean 'true' in order to create required dex integration
# resources.

# Automatically creates Istio VirtualService or Ingress objects.
dexIntegration:
  enabled: true
  svc:
    name: dex
    port: 5556
    namespace: dex

  # one of: 'internal', 'external'
  # * internal - the in-kubernetes svc address will be used as the dex IdP
  #              Issuer address.
  #   example: dex.dex.svc.cluster.local
  # * external - the .Values.dexIntegration.host will be used as the dex IdP
  #              Issuer address.
  #   example: dex.example.com
  # Currently only 'internal' is supported.
  integrationType: internal

  # One of: 'istio', 'ingress'.
  # Currently only 'istio' is supported.
  integrationMode: istio

  # 'host' must be set if .Values.dexIntegration.integrationType: external
  host:

  # If .Values.dexIntegration.integrationType: internal, dex IdP will be
  # available under this relative URL Prefix.
  urlPrefix: /dex

  integrationModeConfig:
    istio:
    ingress:
      class:
      annotations:

auth:
  userHeaderName: kubeflow-userid
  userIdPrefix: ""

clusterDomain: cluster.local

# apiVersion: v1
# data:
#   ConMaxLifeTime: 120s
#   DEFAULT_CACHE_STALENESS: ""
#   MAXIMUM_CACHE_STALENESS: ""
#   appName: pipeline
#   appVersion: 2.0.1
#   autoUpdatePipelineDefaultVersion: "true"
#   bucketName: mlpipeline
#   cacheDb: cachedb
#   cacheImage: gcr.io/google-containers/busybox
#   cacheNodeRestrictions: "false"
#   cronScheduleTimezone: UTC
#   dbHost: mysql
#   dbPort: "3306"
#   defaultPipelineRoot: ""
#   mlmdDb: metadb
#   pipelineDb: mlpipeline
#   warning: |
#     1. Do not use kubectl to edit this configmap, because some values are used
#     during kustomize build. Instead, change the configmap and apply the entire
#     kustomize manifests again.
#     2. After updating the configmap, some deployments may need to be restarted
#     until the changes take effect. A quick way to restart all deployments in a
#     namespace: `kubectl rollout restart deployment -n <your-namespace>`.
# kind: ConfigMap
# metadata:
#   labels:
#     app.kubernetes.io/component: ml-pipeline
#     app.kubernetes.io/name: kubeflow-pipelines
#     application-crd-id: kubeflow-pipelines
#   name: pipeline-install-config
#   namespace: kubeflow